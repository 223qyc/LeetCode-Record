# 最长连续序列
## 题目描述
给定一个未排序的整数数组`nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为`O(n)`的算法解决此问题。

**示例 1：**

    输入：nums = [100,4,200,1,3,2]
    输出：4
    解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
**示例 2：**

    输入：nums = [0,3,7,2,5,8,4,6,0,1]
    输出：9
**示例 3：**

    输入：nums = [1,0,1,2]
    输出：3
 

**提示：**
- 0 <= nums.length <= 105
- -109 <= nums[i] <= 109

## 题目解答
这个题目首先就规定了时间复杂度，因此需要思考一个满足其要求的办法。

显然排序后再处理这明确超出了实际要求，所以需要思考另外的方法。

因此我们思考，首先要将数组中的重复数据删除，这就用到无序集合的数据结构，本质上是哈希表存储。

现在我们再思考，对于一个例如12345的序列，从1开始到5，那么也必定存在2-5，这可能会产生不必要的再查询。因此我们可以每次查看其前一个数是否在集合中存在，存在则跳过，这样我们就可以做到每次都处理第一个开始的数字。

代码如下：
```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.empty()) return 0;
        
        unordered_set<int> num_set(nums.begin(), nums.end()); // 直接初始化哈希表
        int max_length = 1;

        for (int num : num_set) {
            // 只处理连续序列的起点（避免重复计算）
            if (num_set.find(num - 1) == num_set.end()) {
                int current_num = num;
                int current_length = 1;

                // 向右扩展序列（迭代代替递归）
                while (num_set.find(current_num + 1) != num_set.end()) {
                    current_num++;
                    current_length++;
                }
                max_length = max(max_length, current_length);
            }
        }
        return max_length;
    }
};
```

## 关于记忆搜索的题外话
再查看最佳答案时，发现竟然有一个2ms的答案，十分震惊，但代码晦涩难懂，使用了记忆化搜索的方式。此方法虽效率极高，但存在着一定的隐患，效率可能在一些情况下极好，但工程性较差。接下来是一些关于记忆化搜索的小总结，来自LLM的总结。
记忆化搜索（Memoization）是一种优化技术，通过存储重复子问题的计算结果来避免重复计算，从而提升算法效率。它常用于递归算法中，尤其是动态规划问题。

---

### **核心原理**
1. **重叠子问题**：当问题可以分解为多个重复的子问题时，直接递归会导致大量重复计算。
2. **缓存结果**：将已计算的子问题结果保存起来（通常用数组、哈希表等数据结构），下次需要时直接查表，避免重复计算。

---

### **与动态规划的关系**
- 记忆化搜索是动态规划的“自顶向下”实现（递归），而传统动态规划是“自底向上”实现（迭代）。
- 两者本质都是利用空间换时间，但记忆化搜索更直观，代码更贴近问题描述。

---

### **实际例子**

#### 1. 斐波那契数列
**问题**：计算第`n`个斐波那契数（`F(n) = F(n-1) + F(n-2)`）。  
**普通递归**：时间复杂度 `O(2^n)`（指数级）。  
**记忆化搜索**：时间复杂度降为 `O(n)`。
```python
def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

#### 2. 爬楼梯问题
**问题**：每次可以爬1或2阶台阶，求爬到第`n`阶的方法数。  
**记忆化实现**：
```python
def climb_stairs(n, memo={}):
    if n in memo:
        return memo[n]
    if n == 1:
        return 1
    if n == 2:
        return 2
    memo[n] = climb_stairs(n-1, memo) + climb_stairs(n-2, memo)
    return memo[n]
```

#### 3. 网格路径问题
**问题**：在`m×n`网格中，从左上角到右下角只能向右或向下移动，求路径总数。  
**记忆化优化**：
```python
def unique_paths(m, n, memo={}):
    key = f"{m},{n}"
    if key in memo:
        return memo[key]
    if m == 1 or n == 1:
        return 1
    memo[key] = unique_paths(m-1, n, memo) + unique_paths(m, n-1, memo)
    return memo[key]
```

---

### **适用场景**
- **问题特性**：需满足最优子结构和重叠子问题（如动态规划问题）。
- **典型应用**：组合数学、图搜索（如DFS剪枝）、字符串处理（如编辑距离）。

---

### **优缺点**
- **优点**：代码直观，易于实现；避免重复计算，显著提升效率。
- **缺点**：递归可能引发栈溢出；需额外空间存储中间结果。

---

### **总结**
记忆化搜索通过缓存子问题解，将指数级时间复杂度优化为多项式级，是动态规划问题的经典实现方式之一。实际应用中需权衡递归开销与空间成本。